#include <stdio.h>

#define LENGTH(array) ( (sizeof(array)) / (sizeof(array[0])) )		// 数组长度
#define swap(a,b) (a^=b,b^=a,a^=b)

/*
第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
N为数组下标索引值，如数组中第1个数对应的N为0。
 */
void maxheap_down(int a[], int start, int end)
{
    int c = start;            // 当前节点的位置
    int l = 2*c + 1;       	  // 左孩子的位置
    int tmp = a[c];           // 当前节点的大小
    for (; l <= end; c=l,l=2*l+1)
    {
        // "l"是左孩子，"l+1"是右孩子
        if ( l < end && a[l] < a[l+1])
            l++;       		 // 左右两孩子中选择较大者，即m_heap[l+1]
        if (tmp >= a[l])
            break;      	 // 调整结束
        else           		 // 交换值
        {
            a[c] = a[l];
            a[l]= tmp;
        }
    }
}
/*
堆排序(从小到大)
 */
void heap_sort_asc(int a[], int n)
{
    int i;
    // 从(n/2-1) --> 0逐次遍历。遍历之后，得到的数组是一个大顶堆。
    for (i = n / 2 - 1; i >= 0; i--)
        maxheap_down(a, i, n-1);
    // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
    for (i = n - 1; i > 0; i--)
    {
        // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。
        swap(a[0], a[i]);
        // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。
        // 保证a[i-1]是a[0...i-1]中的最大值。
        maxheap_down(a, 0, i-1);
    }
}
/*
第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。
N为数组下标索引值，如数组中第1个数对应的N为0。
 */
void minheap_down(int a[], int start, int end)
{
    int c = start;           	 // 当前节点的位置
    int l = 2*c + 1;        	 // 左孩子的位置
    int tmp = a[c];              // 当前节点的大小
    for (; l <= end; c=l,l=2*l+1)
    {
        // "l"是左孩子，"l+1"是右孩子
        if ( l < end && a[l] > a[l+1])
            l++;        // 左右两孩子中选择较小者
        if (tmp <= a[l])
            break;      // 调整结束
        else            // 交换值
        {
            a[c] = a[l];
            a[l]= tmp;
        }
    }
}

/*
堆排序(从大到小)
 */
void heap_sort_desc(int a[], int n)
{
    int i;
    // 从(n/2-1) --> 0逐次遍历每。遍历之后，得到的数组实际上是一个小顶堆。
    for (i = n / 2 - 1; i >= 0; i--)
        minheap_down(a, i, n-1);
    // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
    for (i = n - 1; i > 0; i--)
    {
        // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最小的。
        swap(a[0], a[i]);
        // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最小堆。
        // 即，保证a[i-1]是a[0...i-1]中的最小值。
        minheap_down(a, 0, i-1);
    }
}

void main()
{
    int i;
    int a[] = {2,3,9,4,70,11,6,1,10,5,8};
    int ilen = LENGTH(a);
    printf("before sort:");
    for (i=0; i<ilen; i++)
        printf("%d ", a[i]);
    printf("\n");
	printf("小顶堆:");
    heap_sort_asc(a, ilen);         // 升序排列
	for (i=0; i<ilen; i++)
        printf("%d ", a[i]);
	printf("\n大顶堆:");
    heap_sort_desc(a, ilen);        // 降序排列
    for (i=0; i<ilen; i++)
        printf("%d ", a[i]);
    printf("\n");
}
